package slice

import "fmt"

//切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容
//切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合

//切片的定义
//var slice_name  [] type

func STest() {
	var s1 []int
	fmt.Printf("值是:%v\n类型是: %T\n", s1, s1)
	fmt.Println("s1 切面的长度为", len(s1), "容量是", cap(s1))

	//	切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含

	addr := [6]int{1, 2, 3, 4, 5, 6}
	fmt.Println("只是一个切片", addr)
	// 数组通过切片表达式 获得切片
	s2 := addr[0:3] // 左包含 又不包含  索引从0 开始 到索引3结束 不包含3
	fmt.Printf("s2的值是%v\ns2的类型是%T\n", s2, s2)
	// 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量
	fmt.Println("切片的长度为", len(s2), "切片的容量为", cap(s2))

	//对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内
	//简短声明定义切片并复制
	s3 := []string{"上海", "北京", "天津", "南京", "重庆"} //使用简短声明创建切片时，长度由提供的初始值个数决定，容量与长度相等

	fmt.Printf("切片的长度为: %v\n 切片的容量为%v\n", len(s3), cap(s3))

}

func MackS() {
	//使用make()函数构造切片
	//make([]T, size, cap)
	s4 := make([]int, 5, 9) // 使用make函数创建切片可以明确指定切片的长度和容量。

	fmt.Println(s4)
	fmt.Printf("切片的大小为 %v\n 该切片的容量为: %v\n", len(s4), cap(s4))

	//完整切片表达式
	//对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：
	//a[low : high : max]  max  切牌容量
	//简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0
	s5 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	s6 := s5[1:5:9] // 切片或者数组在切片 容量长度 不能大于 原始容量-low 的个数   否则 运行 panic
	fmt.Printf("s5的切片为：%v\n s5的容量为：%v\n s5的长度为%v\n", s5, cap(s5), len(s5))
	fmt.Printf("s6的切片为：%v\n s6的容量为：%v\n s6的长度为%v\n", s6, cap(s6), len(s6))
}

func SSlice() {
	//	切片的本质
	//切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）

	//	要检查切片是否为空，请始终使用len(s) == 0来判断，而不应该使用s == nil来判断
	a := make([]string, 0) // make 一个切片时 容量时可选项  长度是必选项
	b := []int{}
	fmt.Println(len(a) == 0)
	fmt.Println(len(b) == 0)

}

func SCopy() {
	//切片的赋值拷贝
	s1 := []int{1, 2, 3, 4, 5}
	s2 := s1
	s2[1] = 300
	fmt.Println(s1, s2)
	//  切片之间的赋值操作是浅拷贝（shallow copy）
	//	切片是引用类型，赋值操作会导致两个切片引用同一个底层数组。这意味着对一个切片的修改会影响到其他引用同一底层数组的切片。
	//	切片的赋值操作只拷贝了切片的引用，而不会复制底层数组

	//想要实现深拷贝（deep copy），可以使用copy函数。copy函数可以将一个切片的内容复制到另一个切片中，创建两个独立的切片，它们底层引用不同的数组

	s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}

	s4 := make([]int, len(s3))
	copy(s4, s3)
	s4[4] = 300
	fmt.Println("s3", s3)
	fmt.Println("s4", s4)
}

func RSlice() {
	// 切片的遍历
	s1 := []int{12, 3, 4, 5, 6, 7, 8, 9, 12}

	fmt.Println(s1)
	// 1
	for _, v := range s1 {
		//fmt.Println("下标", i)
		fmt.Println("值", v)
	}

	// 2
	for i := 0; i < len(s1); i++ {
		fmt.Println(i, s1[i])
	}
}

//  append()可以为切片动态添加元素

func AppAlice() {

	a := []int{1, 2, 3, 4, 5}
	fmt.Println("打印原始切片", a)
	fmt.Println("追加后的切片", append(a, 6, 7, 8, 9, 10))

	var s1 []int
	fmt.Println("通过var声明的零值切片可以在append()函数直接使用，无需初始化。", append(s1, 1, 2, 3, 4, 5))

	//	每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。

	//	例子
	var sT []int
	for i := 0; i <= 10; i++ {
		sT = append(sT, i)
		fmt.Printf("%v  len: %d  cap: %d  ptr:%p\n", sT, len(sT), cap(sT), sT)
		//append()函数将元素追加到切片的最后并返回该切片。
		//切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍
	}

	// 不仅支持 把元素追加到切片  还支持把 切片追加到 切片

	s2 := []string{"上海", "天津", "南京", "北京"}
	s3 := []string{"河北", "河南", "山东"}
	s3 = append(s3, s2...) //     在切片操作中，... 的作用是将一个切片打散，使其成为一个可变参数序列。
	//s2... 是一个切片 s2 的语法糖写法，用于在 append() 函数的第二个参数中将 s2 的元素逐个打散，作为可变参数传递给 append() 函数。这样做的目的是将 s2 中的所有元素一个一个地追加到 s3 中
	fmt.Println(s3)

}

// 使用copy()函数复制切片

func CopySlice() {
	a := []int{1, 2, 3, 4, 5}
	b := a
	fmt.Println(a)
	fmt.Println(b)
	b[0] = 30 //
	fmt.Println(a)
	fmt.Println(b)
	//	切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化

	//Go语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中
	//	用法   copy(destSlice,srcSlice []T)  srcSlice: 数据来源切片    destSlice: 目标切片  T  type   类型

	s := []int{11, 22, 33, 44}
	s1 := make([]int, 4, 4)
	copy(s1, s)
	fmt.Println(s)
	fmt.Println(s1)
	s1[0] = 100
	fmt.Println("修改s1[0]后,s", s)
	fmt.Println("修改s1[0]后,s1", s1)

	//	下面是使用 copy() 函数时需要注意的事项：
	//
	//长度限制: copy() 函数会根据两个切片的长度，将较小的切片进行复制。复制的元素数量等于两个切片中长度较小的那个。如果目标切片的长度小于源切片的长度，只会复制目标切片长度范围内的元素。
	//数据重写: 如果目标切片的长度大于源切片的长度，copy() 函数会将源切片的元素复制到目标切片中，但是会覆盖目标切片多出来的部分。因此，在使用 copy() 时要确保目标切片足够长，否则可能会导致数据丢失或者意外的结果。
	//数据共享: copy() 函数是将元素从一个切片复制到另一个切片，复制的是元素的值而不是指向的数据。但是，如果切片中存储的是引用类型（如切片、映射或指针等），则复制的只是引用，导致两个切片共享相同的底层数据。修改一个切片的元素可能会影响到另一个切片的相应位置元素。
	//copy() 函数返回值: copy() 函数会返回实际复制的元素数量。可以根据返回值来判断复制是否成功，以及源切片和目标切片的长度关系。
}

// go 语言中没有删除切片的元素的专用方法  可以使用切片本身的特性来删除元素

//方法一：使用 append 函数和切片操作符
//你可以使用 append 函数结合切片操作符来删除一个或多个元素。首先，你需要将要删除的元素索引之前和之后的部分重新组合成新的切片
//方法二：使用 copy 函数
//另一种方式是使用 copy 函数将要保留的元素复制到原始数组上，并更新其长度。这样就相当于移除了指定位置上的元素

func DelSlice() {
	// 方法一
	s := []int{1, 2, 8, 3, 4}
	s = append(s[:2], s[3:]...) // 将要删除索引之前和之后的部分重新组合成新的切片
	// 要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)
	fmt.Println(s)

	// 方法二
	a := []int{9, 23, 8, 7, 6}
	copy(a[1:], a[2:]) //  将剩余部分向左移动以覆盖被删除项
	a = a[:len(a)-1]   // 更新长度，删除最后一个元素
	fmt.Println(a)

}
